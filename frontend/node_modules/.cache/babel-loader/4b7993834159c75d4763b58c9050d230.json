{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useMemo, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport get from 'lodash/get';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useVersion } from '../controller';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = {\n  action: CRUD_GET_MANY\n};\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false, refetch }\n * - success: { data: [data from response], loading: false, loaded: true, refetch }\n * - error: { error: [error from response], loading: false, loaded: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetMany('tags', [1, 2, 3]);\n * useGetMany('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param ids The resource identifiers, e.g. [123, 456, 789]\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\n\nvar useGetMany = function (resource, ids, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {\n      enabled: true\n    };\n  } // we can't use useQueryWithStore here because we're aggregating queries first\n  // therefore part of the useQueryWithStore logic will have to be repeated below\n\n\n  var selectMany = useMemo(makeGetManySelector, []);\n  var data = useSelector(function (state) {\n    return selectMany(state, resource, ids);\n  });\n  var version = useVersion(); // used to allow force reload\n  // used to force a refetch without relying on version\n  // which might trigger other queries as well\n\n  var _b = useSafeSetState(0),\n      innerVersion = _b[0],\n      setInnerVersion = _b[1];\n\n  var refetch = useCallback(function () {\n    setInnerVersion(function (prevInnerVersion) {\n      return prevInnerVersion + 1;\n    });\n  }, [setInnerVersion]);\n\n  var _c = useSafeSetState({\n    data: data,\n    error: null,\n    loading: ids.length !== 0,\n    loaded: data.length !== 0 && !data.includes(undefined),\n    refetch: refetch\n  }),\n      state = _c[0],\n      setState = _c[1];\n\n  if (!isEqual(state.data, data)) {\n    var newState = __assign(__assign({}, state), {\n      data: (data === null || data === void 0 ? void 0 : data.includes(undefined)) ? state.data : data,\n      loading: ((_a = state.data) === null || _a === void 0 ? void 0 : _a.length) !== 0 && (state.loading || (data === null || data === void 0 ? void 0 : data.includes(undefined)))\n    });\n\n    if (!isEqual(state, newState)) {\n      setState(newState);\n    }\n  }\n\n  dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n\n  useEffect(function () {\n    if (options.enabled === false) {\n      return;\n    }\n\n    if (!queriesToCall[resource]) {\n      queriesToCall[resource] = [];\n    }\n    /**\n     * queriesToCall stores the queries to call under the following shape:\n     *\n     * {\n     *   'posts': [\n     *     { ids: [1, 2], setState }\n     *     { ids: [2, 3], setState, onSuccess }\n     *     { ids: [4, 5], setState }\n     *   ],\n     *   'comments': [\n     *     { ids: [345], setState, onFailure }\n     *   ]\n     * }\n     */\n\n\n    queriesToCall[resource] = queriesToCall[resource].concat({\n      ids: ids,\n      setState: setState,\n      onSuccess: options && options.onSuccess,\n      onFailure: options && options.onFailure\n    });\n    callQueries(); // debounced by lodash\n  },\n  /* eslint-disable react-hooks/exhaustive-deps */\n  [JSON.stringify({\n    resource: resource,\n    ids: ids,\n    options: options,\n    version: version,\n    innerVersion: innerVersion\n  }), dataProvider]\n  /* eslint-enable react-hooks/exhaustive-deps */\n  );\n  return state;\n};\n/**\n * Memoized selector for getting an array of resources based on an array of ids\n *\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\n */\n\n\nvar makeGetManySelector = function () {\n  return createSelector([function (state, resource) {\n    return get(state, ['admin', 'resources', resource, 'data']);\n  }, function (_, __, ids) {\n    return ids;\n  }], function (resourceData, ids) {\n    return resourceData ? ids.map(function (id) {\n      return resourceData[id];\n    }) : ids.map(function (id) {\n      return undefined;\n    });\n  });\n};\n/**\n * Call the dataProvider once per resource\n */\n\n\nvar callQueries = debounce(function () {\n  var resources = Object.keys(queriesToCall);\n  resources.forEach(function (resource) {\n    var queries = __spreadArray([], queriesToCall[resource], true); // cloning to avoid side effects\n\n    /**\n     * Extract ids from queries, aggregate and deduplicate them\n     *\n     * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n     */\n\n\n    var accumulatedIds = queries.reduce(function (acc, _a) {\n      var ids = _a.ids;\n      return union(acc, ids);\n    }, []) // concat + unique\n    .filter(function (v) {\n      return v != null && v !== '';\n    }); // remove null values\n\n    if (accumulatedIds.length === 0) {\n      // no need to call the data provider if all the ids are null\n      queries.forEach(function (_a) {\n        var ids = _a.ids,\n            setState = _a.setState,\n            onSuccess = _a.onSuccess;\n        setState({\n          data: emptyArray,\n          loading: false,\n          loaded: true\n        });\n\n        if (onSuccess) {\n          onSuccess({\n            data: emptyArray\n          });\n        }\n      });\n      return;\n    }\n\n    dataProvider.getMany(resource, {\n      ids: accumulatedIds\n    }, DataProviderOptions).then(function (response) {\n      // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var ids = _a.ids,\n              setState = _a.setState,\n              onSuccess = _a.onSuccess;\n          setState(function (prevState) {\n            return __assign(__assign({}, prevState), {\n              error: null,\n              loading: false,\n              loaded: true\n            });\n          });\n\n          if (onSuccess) {\n            var subData = ids.map(function (id) {\n              return response.data.find(function (datum) {\n                return datum.id == id;\n              });\n            } // eslint-disable-line eqeqeq\n            );\n            onSuccess({\n              data: subData\n            });\n          }\n        });\n      });\n    }).catch(function (error) {\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var setState = _a.setState,\n              onFailure = _a.onFailure;\n          setState({\n            error: error,\n            loading: false,\n            loaded: false\n          });\n          onFailure && onFailure(error);\n        });\n      });\n    });\n    delete queriesToCall[resource];\n  });\n});\nvar emptyArray = [];\nexport default useGetMany;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","useCallback","useMemo","useEffect","ReactDOM","useSelector","createSelector","debounce","union","isEqual","get","CRUD_GET_MANY","useSafeSetState","useDataProvider","useVersion","queriesToCall","dataProvider","DataProviderOptions","action","useGetMany","resource","ids","options","_a","enabled","selectMany","makeGetManySelector","data","state","version","_b","innerVersion","setInnerVersion","refetch","prevInnerVersion","_c","error","loading","loaded","includes","undefined","setState","newState","onSuccess","onFailure","callQueries","JSON","stringify","_","__","resourceData","map","id","resources","keys","forEach","queries","accumulatedIds","reduce","acc","filter","v","emptyArray","getMany","then","response","unstable_batchedUpdates","prevState","subData","find","datum","catch"],"sources":["/home/lightsong/workspace/freact/frontend/node_modules/ra-core/esm/dataProvider/useGetMany.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useMemo, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport get from 'lodash/get';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useVersion } from '../controller';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = { action: CRUD_GET_MANY };\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false, refetch }\n * - success: { data: [data from response], loading: false, loaded: true, refetch }\n * - error: { error: [error from response], loading: false, loaded: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetMany('tags', [1, 2, 3]);\n * useGetMany('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param ids The resource identifiers, e.g. [123, 456, 789]\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nvar useGetMany = function (resource, ids, options) {\n    var _a;\n    if (options === void 0) { options = { enabled: true }; }\n    // we can't use useQueryWithStore here because we're aggregating queries first\n    // therefore part of the useQueryWithStore logic will have to be repeated below\n    var selectMany = useMemo(makeGetManySelector, []);\n    var data = useSelector(function (state) {\n        return selectMany(state, resource, ids);\n    });\n    var version = useVersion(); // used to allow force reload\n    // used to force a refetch without relying on version\n    // which might trigger other queries as well\n    var _b = useSafeSetState(0), innerVersion = _b[0], setInnerVersion = _b[1];\n    var refetch = useCallback(function () {\n        setInnerVersion(function (prevInnerVersion) { return prevInnerVersion + 1; });\n    }, [setInnerVersion]);\n    var _c = useSafeSetState({\n        data: data,\n        error: null,\n        loading: ids.length !== 0,\n        loaded: data.length !== 0 && !data.includes(undefined),\n        refetch: refetch,\n    }), state = _c[0], setState = _c[1];\n    if (!isEqual(state.data, data)) {\n        var newState = __assign(__assign({}, state), { data: (data === null || data === void 0 ? void 0 : data.includes(undefined)) ? state.data : data, loading: ((_a = state.data) === null || _a === void 0 ? void 0 : _a.length) !== 0 &&\n                (state.loading || (data === null || data === void 0 ? void 0 : data.includes(undefined))) });\n        if (!isEqual(state, newState)) {\n            setState(newState);\n        }\n    }\n    dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n    useEffect(function () {\n        if (options.enabled === false) {\n            return;\n        }\n        if (!queriesToCall[resource]) {\n            queriesToCall[resource] = [];\n        }\n        /**\n         * queriesToCall stores the queries to call under the following shape:\n         *\n         * {\n         *   'posts': [\n         *     { ids: [1, 2], setState }\n         *     { ids: [2, 3], setState, onSuccess }\n         *     { ids: [4, 5], setState }\n         *   ],\n         *   'comments': [\n         *     { ids: [345], setState, onFailure }\n         *   ]\n         * }\n         */\n        queriesToCall[resource] = queriesToCall[resource].concat({\n            ids: ids,\n            setState: setState,\n            onSuccess: options && options.onSuccess,\n            onFailure: options && options.onFailure,\n        });\n        callQueries(); // debounced by lodash\n    }, \n    /* eslint-disable react-hooks/exhaustive-deps */\n    [\n        JSON.stringify({\n            resource: resource,\n            ids: ids,\n            options: options,\n            version: version,\n            innerVersion: innerVersion,\n        }),\n        dataProvider,\n    ]\n    /* eslint-enable react-hooks/exhaustive-deps */\n    );\n    return state;\n};\n/**\n * Memoized selector for getting an array of resources based on an array of ids\n *\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\n */\nvar makeGetManySelector = function () {\n    return createSelector([\n        function (state, resource) {\n            return get(state, ['admin', 'resources', resource, 'data']);\n        },\n        function (_, __, ids) { return ids; },\n    ], function (resourceData, ids) {\n        return resourceData\n            ? ids.map(function (id) { return resourceData[id]; })\n            : ids.map(function (id) { return undefined; });\n    });\n};\n/**\n * Call the dataProvider once per resource\n */\nvar callQueries = debounce(function () {\n    var resources = Object.keys(queriesToCall);\n    resources.forEach(function (resource) {\n        var queries = __spreadArray([], queriesToCall[resource], true); // cloning to avoid side effects\n        /**\n         * Extract ids from queries, aggregate and deduplicate them\n         *\n         * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n         */\n        var accumulatedIds = queries\n            .reduce(function (acc, _a) {\n            var ids = _a.ids;\n            return union(acc, ids);\n        }, []) // concat + unique\n            .filter(function (v) { return v != null && v !== ''; }); // remove null values\n        if (accumulatedIds.length === 0) {\n            // no need to call the data provider if all the ids are null\n            queries.forEach(function (_a) {\n                var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\n                setState({\n                    data: emptyArray,\n                    loading: false,\n                    loaded: true,\n                });\n                if (onSuccess) {\n                    onSuccess({ data: emptyArray });\n                }\n            });\n            return;\n        }\n        dataProvider\n            .getMany(resource, { ids: accumulatedIds }, DataProviderOptions)\n            .then(function (response) {\n            // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n            return ReactDOM.unstable_batchedUpdates(function () {\n                return queries.forEach(function (_a) {\n                    var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\n                    setState(function (prevState) { return (__assign(__assign({}, prevState), { error: null, loading: false, loaded: true })); });\n                    if (onSuccess) {\n                        var subData = ids.map(function (id) {\n                            return response.data.find(function (datum) { return datum.id == id; });\n                        } // eslint-disable-line eqeqeq\n                        );\n                        onSuccess({ data: subData });\n                    }\n                });\n            });\n        })\n            .catch(function (error) {\n            return ReactDOM.unstable_batchedUpdates(function () {\n                return queries.forEach(function (_a) {\n                    var setState = _a.setState, onFailure = _a.onFailure;\n                    setState({ error: error, loading: false, loaded: false });\n                    onFailure && onFailure(error);\n                });\n            });\n        });\n        delete queriesToCall[resource];\n    });\n});\nvar emptyArray = [];\nexport default useGetMany;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}